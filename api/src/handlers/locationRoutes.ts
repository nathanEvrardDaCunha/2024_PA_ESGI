import express, {Request, Response} from "express";import {	createLocation,	getAllLocation,	getLocationById, getLocationByPersonId,	updateLocation, updateLocationByPersonId,	findLocationByUserId} from "../repository/locationsRepository";import {Prisma} from "@prisma/client";import locationValidation, {	LocationUpdateRequest,	LocationUpdateValidation,	LocationValidation} from "./validators/location-validation";import {PersonValidation} from "./validators/person-validation";import {generateValidationErrorMessage} from "./validators/generate-validation-message";import {prisma} from "../index";const locationRouter = express.Router();locationRouter.get('/', async (req: Request, res: Response) => {	//TODO : Check all argument validation	//TODO : Write the service rules		try {		const locations = await getAllLocation();		res.status(200).json(locations);	} catch (error) {		console.error('Error fetching locations:', error);		res.status(500).json({error: 'Internal Server Error'});	}});locationRouter.get('/:id', async (req: Request, res: Response) => {	//TODO : Check all argument validation	//TODO : Write the service rules		try {		const location = await getLocationById(req.params.id);		if (!location) {			return res.status(404).json({ error: 'Location not found' });		}		res.status(200).json(location);	} catch (error) {		console.error('Error fetching location by ID:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});// Route pour obtenir une localisation par l'ID de l'utilisateurlocationRouter.get('/person/:personId', async (req: Request, res: Response) => {	try {		const personId = req.params.personId;		const personLocations = await getLocationByPersonId(personId);		if (!personLocations ) {			return res.status(404).json({ error: 'No locations found for the user' });		}		res.status(200).json(personLocations);	} catch (error) {		console.error('Error fetching locations by user ID:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});locationRouter.patch('/person/:personId', async (req: Request, res: Response) => {	try {		const validationResult = LocationUpdateValidation.validate(req.body);		if (validationResult.error) {			res.status(400).send(generateValidationErrorMessage(validationResult.error.details));			return;		}		const personId = req.params.personId;		const updateData:LocationUpdateRequest=req.body;		const updatedLocation=updateLocationByPersonId(personId,updateData);		if (!updatedLocation) {			return res.status(404).json({ error: 'Person not found' });		}		res.status(200).json(updatedLocation);	} catch (error) {		console.error('Error updating user location:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});locationRouter.post('/user', async (req: Request, res: Response) => {	try {		const email = req.body.email;		const locationData = {			address: req.body.address,			country: req.body.country,			city: req.body.city,			postalCode: req.body.postalCode,			type: 'user-home',			capacity: 999,			status: 'unavailable',		};				const newLocation = await createLocation(locationData, email);		res.status(201).json(newLocation);	} catch (error) {		console.error('Error creating locations:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});locationRouter.patch('/:userId', async (req: Request, res: Response) => {	const { userId } = req.params;	const updatedLocation = req.body;		try {		// Find the location associated with the user ID		const location = await findLocationByUserId(userId);				if (!location) {			return res.status(404).json({ error: 'Location not found' });		}				// Update the location with the provided data		const updatedLocationData = await prisma.location.update({			where: {				id: location.id,			},			data: updatedLocation,		});				res.status(200).json(updatedLocationData);	} catch (error) {		console.error('Error updating location:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});export default locationRouter;